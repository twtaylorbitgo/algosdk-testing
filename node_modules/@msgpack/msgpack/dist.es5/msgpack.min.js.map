{"version":3,"sources":["webpack://MessagePack/webpack/universalModuleDefinition","webpack://MessagePack/webpack/bootstrap","webpack://MessagePack/./src/utils/utf8.ts","webpack://MessagePack/./src/ExtData.ts","webpack://MessagePack/./src/utils/int.ts","webpack://MessagePack/./src/timestamp.ts","webpack://MessagePack/./src/ExtensionCodec.ts","webpack://MessagePack/./src/utils/typedArrays.ts","webpack://MessagePack/./src/wasmFunctions.ts","webpack://MessagePack/./src/Encoder.ts","webpack://MessagePack/./src/encode.ts","webpack://MessagePack/./src/utils/prettyByte.ts","webpack://MessagePack/./src/CachedKeyDecoder.ts","webpack://MessagePack/./src/Decoder.ts","webpack://MessagePack/./src/decode.ts","webpack://MessagePack/./src/utils/stream.ts","webpack://MessagePack/./src/decodeAsync.ts","webpack://MessagePack/./src/index.ts"],"names":["root","factory","exports","module","define","amd","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","TEXT_ENCODING_AVAILABLE","TextEncoder","TextDecoder","utf8Count","str","strLength","length","byteLength","pos","charCodeAt","extra","sharedTextEncoder","undefined","utf8EncodeTE","encodeInto","output","outputOffset","subarray","set","encode","CHUNK_SIZE","utf8DecodeJs","bytes","inputOffset","offset","end","units","result","byte1","push","byte2","byte3","unit","String","fromCharCode","sharedTextDecoder","type","data","setInt64","view","high","Math","floor","low","setUint32","getInt64","getInt32","getUint32","TIMESTAMP32_MAX_SEC","TIMESTAMP64_MAX_SEC","encodeTimeSpecToTimestamp","sec","nsec","rv","Uint8Array","DataView","buffer","secHigh","secLow","encodeDateToTimeSpec","date","msec","getTime","nsecInSec","encodeTimestampExtension","Date","decodeTimestampToTimeSpec","byteOffset","nsec30AndSecHigh2","Error","decodeTimestampExtension","timeSpec","timestampExtension","decode","builtInEncoders","builtInDecoders","encoders","decoders","register","index","tryToEncode","encoder","ExtData","decoder","defaultCodec","ExtensionCodec","ensureUint8Array","ArrayBuffer","isView","from","wm","WASM_AVAILABLE","utf8EncodeWasm","inputByteLength","inputU16BePtr","malloc","destPtr","destByteLength","inputView","memory","setUint16","setMemoryStr","outputPtr","outputLength","utf8EncodeUint16Array","free","utf8DecodeWasm","src","size","inputPtr","outputArraySize","utf8DecodeToUint16Array","apply","chunk","safeStringFromCharCodeU16","Uint16Array","DEFAULT_MAX_DEPTH","DEFAULT_INITIAL_BUFFER_SIZE","extensionCodec","maxDepth","initialBufferSize","sortKeys","forceFloat32","depth","encodeNil","encodeBoolean","encodeNumber","encodeString","encodeObject","getUint8Array","ensureBufferSizeToWrite","sizeToWrite","requiredSize","resizeBuffer","newSize","newBuffer","newBytes","newView","writeU8","Number","isSafeInteger","writeU16","writeU32","writeU64","writeI8","writeI16","writeI32","writeI64","writeF32","writeF64","writeStringHeader","maxSize","ouputLength","utf8EncodeJs","ext","encodeExtension","Array","isArray","encodeArray","encodeBinary","toString","encodeMap","writeU8a","item","keys","sort","setUint8","values","setInt8","setInt16","setInt32","setFloat32","setFloat64","setUint64","defaultEncodeOptions","options","prettyByte","byte","abs","padStart","DEFAULT_MAX_KEY_LENGTH","DEFAULT_MAX_LENGTH_PER_KEY","maxKeyLength","maxLengthPerKey","caches","canBeCached","records","recordsLength","FIND_CHUNK","record","recordBytes","j","store","random","cachedValue","slicedCopyOfBytes","slice","HEAD_BYTE_REQUIRED","EMPTY_VIEW","EMPTY_BYTES","DataViewIndexOutOfBoundsError","getInt8","e","constructor","MORE_DATA","DEFAULT_MAX_LENGTH","sharedCachedKeyDecoder","maxStrLength","maxBinLength","maxArrayLength","maxMapLength","maxExtLength","cachedKeyDecoder","totalPos","headByte","stack","setBuffer","bufferView","createDataView","appendBuffer","hasRemaining","remainingData","newData","concated","createNoExtraBytesError","posToShow","RangeError","decodeSingleSync","decodeSync","decodeSingleAsync","stream","decoded","decodeArrayStream","decodeMultiAsync","decodeStream","isArrayHeaderRequired","arrayItemsLeft","readArraySize","complete","DECODE","readHeadByte","pushMapState","pushArrayState","decodeUtf8String","readF32","readF64","readU8","readU16","readU32","readU64","readI8","readI16","readI32","readI64","lookU8","lookU16","lookU32","decodeBinary","decodeExtension","state","array","position","pop","keyType","map","readCount","headerOffset","stateIsMapKey","stringBytes","utf8DecodeTD","headOffset","extType","getUint8","getUint16","getInt16","getFloat32","getFloat64","defaultDecodeOptions","ensureAsyncIterabe","streamLike","asyncIterator","reader","getReader","read","done","releaseLock","asyncIterableFromStream","decodeAsync"],"mappings":"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","file":"msgpack.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"MessagePack\"] = factory();\n\telse\n\t\troot[\"MessagePack\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","export const TEXT_ENCODING_AVAILABLE =\n  process.env.TEXT_ENCODING !== \"never\" && (typeof TextEncoder !== \"undefined\" && typeof TextDecoder !== \"undefined\");\n\nexport function utf8Count(str: string): number {\n  const strLength = str.length;\n\n  let byteLength = 0;\n  let pos = 0;\n  while (pos < strLength) {\n    let value = str.charCodeAt(pos++);\n\n    if ((value & 0xffffff80) === 0) {\n      // 1-byte\n      byteLength++;\n      continue;\n    } else if ((value & 0xfffff800) === 0) {\n      // 2-bytes\n      byteLength += 2;\n    } else {\n      // handle surrogate pair\n      if (value >= 0xd800 && value <= 0xdbff) {\n        // high surrogate\n        if (pos < strLength) {\n          const extra = str.charCodeAt(pos);\n          if ((extra & 0xfc00) === 0xdc00) {\n            ++pos;\n            value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n          }\n        }\n      }\n\n      if ((value & 0xffff0000) === 0) {\n        // 3-byte\n        byteLength += 3;\n      } else {\n        // 4-byte\n        byteLength += 4;\n      }\n    }\n  }\n  return byteLength;\n}\n\nexport function utf8EncodeJs(str: string, output: Uint8Array, outputOffset: number): void {\n  const strLength = str.length;\n  let offset = outputOffset;\n  let pos = 0;\n  while (pos < strLength) {\n    let value = str.charCodeAt(pos++);\n\n    if ((value & 0xffffff80) === 0) {\n      // 1-byte\n      output[offset++] = value;\n      continue;\n    } else if ((value & 0xfffff800) === 0) {\n      // 2-bytes\n      output[offset++] = ((value >> 6) & 0x1f) | 0xc0;\n    } else {\n      // handle surrogate pair\n      if (value >= 0xd800 && value <= 0xdbff) {\n        // high surrogate\n        if (pos < strLength) {\n          const extra = str.charCodeAt(pos);\n          if ((extra & 0xfc00) === 0xdc00) {\n            ++pos;\n            value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n          }\n        }\n      }\n\n      if ((value & 0xffff0000) === 0) {\n        // 3-byte\n        output[offset++] = ((value >> 12) & 0x0f) | 0xe0;\n        output[offset++] = ((value >> 6) & 0x3f) | 0x80;\n      } else {\n        // 4-byte\n        output[offset++] = ((value >> 18) & 0x07) | 0xf0;\n        output[offset++] = ((value >> 12) & 0x3f) | 0x80;\n        output[offset++] = ((value >> 6) & 0x3f) | 0x80;\n      }\n    }\n\n    output[offset++] = (value & 0x3f) | 0x80;\n  }\n}\n\nconst sharedTextEncoder = TEXT_ENCODING_AVAILABLE ? new TextEncoder() : undefined;\nexport const TEXT_ENCODER_THRESHOLD = process.env.TEXT_ENCODING !== \"force\" ? 200 : 0;\n\nfunction utf8EncodeTEencode(str: string, output: Uint8Array, outputOffset: number): void {\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  output.set(sharedTextEncoder!.encode(str), outputOffset);\n}\n\nfunction utf8EncodeTEencodeInto(str: string, output: Uint8Array, outputOffset: number): void {\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  sharedTextEncoder!.encodeInto(str, output.subarray(outputOffset));\n}\n\nexport const utf8EncodeTE =\n  sharedTextEncoder && sharedTextEncoder.encodeInto ? utf8EncodeTEencodeInto : utf8EncodeTEencode;\n\nconst CHUNK_SIZE = 0x10_000;\n\nexport function utf8DecodeJs(bytes: Uint8Array, inputOffset: number, byteLength: number): string {\n  let offset = inputOffset;\n  const end = offset + byteLength;\n\n  const units: Array<number> = [];\n  let result = \"\";\n  while (offset < end) {\n    const byte1 = bytes[offset++];\n    if ((byte1 & 0x80) === 0) {\n      // 1 byte\n      units.push(byte1);\n    } else if ((byte1 & 0xe0) === 0xc0) {\n      // 2 bytes\n      const byte2 = bytes[offset++] & 0x3f;\n      units.push(((byte1 & 0x1f) << 6) | byte2);\n    } else if ((byte1 & 0xf0) === 0xe0) {\n      // 3 bytes\n      const byte2 = bytes[offset++] & 0x3f;\n      const byte3 = bytes[offset++] & 0x3f;\n      units.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3);\n    } else if ((byte1 & 0xf8) === 0xf0) {\n      // 4 bytes\n      const byte2 = bytes[offset++] & 0x3f;\n      const byte3 = bytes[offset++] & 0x3f;\n      const byte4 = bytes[offset++] & 0x3f;\n      let unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4;\n      if (unit > 0xffff) {\n        unit -= 0x10000;\n        units.push(((unit >>> 10) & 0x3ff) | 0xd800);\n        unit = 0xdc00 | (unit & 0x3ff);\n      }\n      units.push(unit);\n    } else {\n      units.push(byte1);\n    }\n\n    if (units.length - 4 >= CHUNK_SIZE) {\n      result += String.fromCharCode(...units);\n      units.length = 0;\n    }\n  }\n\n  if (units.length > 0) {\n    result += String.fromCharCode(...units);\n  }\n\n  return result;\n}\n\nconst sharedTextDecoder = TEXT_ENCODING_AVAILABLE ? new TextDecoder() : null;\nexport const TEXT_DECODER_THRESHOLD = process.env.TEXT_DECODER !== \"force\" ? 200 : 0;\n\nexport function utf8DecodeTD(bytes: Uint8Array, inputOffset: number, byteLength: number): string {\n  const stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  return sharedTextDecoder!.decode(stringBytes);\n}\n","/**\n * ExtData is used to handle Extension Types that are not registered to ExtensionCodec.\n */\nexport class ExtData {\n  constructor(readonly type: number, readonly data: Uint8Array) {}\n}\n","// DataView extension to handle int64 / uint64,\n// where the actual range is 53-bits integer (a.k.a. safe integer)\n\nexport function setUint64(view: DataView, offset: number, value: number): void {\n  const high = value / 0x1_0000_0000;\n  const low = value; // high bits are truncated by DataView\n  view.setUint32(offset, high);\n  view.setUint32(offset + 4, low);\n}\n\nexport function setInt64(view: DataView, offset: number, value: number): void {\n  const high = Math.floor(value / 0x1_0000_0000);\n  const low = value; // high bits are truncated by DataView\n  view.setUint32(offset, high);\n  view.setUint32(offset + 4, low);\n}\n\nexport function getInt64(view: DataView, offset: number) {\n  const high = view.getInt32(offset);\n  const low = view.getUint32(offset + 4);\n  return high * 0x1_0000_0000 + low;\n}\n\nexport function getUint64(view: DataView, offset: number) {\n  const high = view.getUint32(offset);\n  const low = view.getUint32(offset + 4);\n  return high * 0x1_0000_0000 + low;\n}\n","// https://github.com/msgpack/msgpack/blob/master/spec.md#timestamp-extension-type\nimport { getInt64, setInt64 } from \"./utils/int\";\n\nexport const EXT_TIMESTAMP = -1;\n\nexport type TimeSpec = {\n  sec: number;\n  nsec: number;\n};\n\nconst TIMESTAMP32_MAX_SEC = 0x100000000 - 1; // 32-bit unsigned int\nconst TIMESTAMP64_MAX_SEC = 0x400000000 - 1; // 34-bit unsigned int\n\nexport function encodeTimeSpecToTimestamp({ sec, nsec }: TimeSpec): Uint8Array {\n  if (sec >= 0 && nsec >= 0 && sec <= TIMESTAMP64_MAX_SEC) {\n    // Here sec >= 0 && nsec >= 0\n    if (nsec === 0 && sec <= TIMESTAMP32_MAX_SEC) {\n      // timestamp 32 = { sec32 (unsigned) }\n      const rv = new Uint8Array(4);\n      const view = new DataView(rv.buffer);\n      view.setUint32(0, sec);\n      return rv;\n    } else {\n      // timestamp 64 = { nsec30 (unsigned), sec34 (unsigned) }\n      const secHigh = sec / 0x100000000;\n      const secLow = sec & 0xffffffff;\n      const rv = new Uint8Array(8);\n      const view = new DataView(rv.buffer);\n      // nsec30 | secHigh2\n      view.setUint32(0, (nsec << 2) | (secHigh & 0x3));\n      // secLow32\n      view.setUint32(4, secLow);\n      return rv;\n    }\n  } else {\n    // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }\n    const rv = new Uint8Array(12);\n    const view = new DataView(rv.buffer);\n    view.setUint32(0, nsec);\n    setInt64(view, 4, sec);\n    return rv;\n  }\n}\n\nexport function encodeDateToTimeSpec(date: Date): TimeSpec {\n  const msec = date.getTime();\n  const sec = Math.floor(msec / 1e3);\n  const nsec = (msec - sec * 1e3) * 1e6;\n\n  // Normalizes { sec, nsec } to ensure nsec is unsigned.\n  const nsecInSec = Math.floor(nsec / 1e9);\n  return {\n    sec: sec + nsecInSec,\n    nsec: nsec - nsecInSec * 1e9,\n  };\n}\n\nexport function encodeTimestampExtension(object: unknown): Uint8Array | null {\n  if (object instanceof Date) {\n    const timeSpec = encodeDateToTimeSpec(object);\n    return encodeTimeSpecToTimestamp(timeSpec);\n  } else {\n    return null;\n  }\n}\n\nexport function decodeTimestampToTimeSpec(data: Uint8Array): TimeSpec {\n  const view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n\n  // data may be 32, 64, or 96 bits\n  switch (data.byteLength) {\n    case 4: {\n      // timestamp 32 = { sec32 }\n      const sec = view.getUint32(0);\n      const nsec = 0;\n      return { sec, nsec };\n    }\n    case 8: {\n      // timestamp 64 = { nsec30, sec34 }\n      const nsec30AndSecHigh2 = view.getUint32(0);\n      const secLow32 = view.getUint32(4);\n      const sec = (nsec30AndSecHigh2 & 0x3) * 0x100000000 + secLow32;\n      const nsec = nsec30AndSecHigh2 >>> 2;\n      return { sec, nsec };\n    }\n    case 12: {\n      // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }\n\n      const sec = getInt64(view, 4);\n      const nsec = view.getUint32(0);\n      return { sec, nsec };\n    }\n    default:\n      throw new Error(`Unrecognized data size for timestamp: ${data.length}`);\n  }\n}\n\nexport function decodeTimestampExtension(data: Uint8Array): Date {\n  const timeSpec = decodeTimestampToTimeSpec(data);\n  return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);\n}\n\nexport const timestampExtension = {\n  type: EXT_TIMESTAMP,\n  encode: encodeTimestampExtension,\n  decode: decodeTimestampExtension,\n};\n","// ExtensionCodec to handle MessagePack extensions\n\nimport { ExtData } from \"./ExtData\";\nimport { timestampExtension } from \"./timestamp\";\n\nexport type ExtensionDecoderType = (data: Uint8Array, extensionType: number) => unknown;\n\nexport type ExtensionEncoderType = (input: unknown) => Uint8Array | null;\n\n// immutable interfce to ExtensionCodec\nexport type ExtensionCodecType = {\n  tryToEncode(object: unknown): ExtData | null;\n  decode(data: Uint8Array, extType: number): unknown;\n};\n\nexport class ExtensionCodec implements ExtensionCodecType {\n  public static readonly defaultCodec: ExtensionCodecType = new ExtensionCodec();\n\n  // built-in extensions\n  private readonly builtInEncoders: Array<ExtensionEncoderType> = [];\n  private readonly builtInDecoders: Array<ExtensionDecoderType> = [];\n\n  // custom extensions\n  private readonly encoders: Array<ExtensionEncoderType> = [];\n  private readonly decoders: Array<ExtensionDecoderType> = [];\n\n  public constructor() {\n    this.register(timestampExtension);\n  }\n\n  public register({\n    type,\n    encode,\n    decode,\n  }: {\n    type: number;\n    encode: ExtensionEncoderType;\n    decode: ExtensionDecoderType;\n  }): void {\n    if (type >= 0) {\n      // custom extensions\n      this.encoders[type] = encode;\n      this.decoders[type] = decode;\n    } else {\n      // built-in extensions\n      const index = 1 + type;\n      this.builtInEncoders[index] = encode;\n      this.builtInDecoders[index] = decode;\n    }\n  }\n\n  public tryToEncode(object: unknown): ExtData | null {\n    // built-in extensions\n    for (let i = 0; i < this.builtInEncoders.length; i++) {\n      const encoder = this.builtInEncoders[i];\n      if (encoder != null) {\n        const data = encoder(object);\n        if (data != null) {\n          const type = -1 - i;\n          return new ExtData(type, data);\n        }\n      }\n    }\n\n    // custom extensions\n    for (let i = 0; i < this.encoders.length; i++) {\n      const encoder = this.encoders[i];\n      if (encoder != null) {\n        const data = encoder(object);\n        if (data != null) {\n          const type = i;\n          return new ExtData(type, data);\n        }\n      }\n    }\n\n    if (object instanceof ExtData) {\n      // to keep ExtData as is\n      return object;\n    }\n    return null;\n  }\n\n  public decode(data: Uint8Array, type: number): unknown {\n    const decoder = type < 0 ? this.builtInDecoders[-1 - type] : this.decoders[type];\n    if (decoder) {\n      return decoder(data, type);\n    } else {\n      // decode() does not fail, returns ExtData instead.\n      return new ExtData(type, data);\n    }\n  }\n}\n","export function ensureUint8Array(buffer: ArrayLike<number> | Uint8Array | ArrayBufferView | ArrayBuffer) {\n  if (buffer instanceof Uint8Array) {\n    return buffer;\n  } else if (ArrayBuffer.isView(buffer)) {\n    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n  } else if (buffer instanceof ArrayBuffer) {\n    return new Uint8Array(buffer);\n  } else {\n    // ArrayLike<number>\n    return Uint8Array.from(buffer);\n  }\n}\n\nexport function createDataView(buffer: ArrayLike<number> | ArrayBufferView | ArrayBuffer): DataView {\n  if (buffer instanceof ArrayBuffer) {\n    return new DataView(buffer);\n  }\n\n  const bufferView = ensureUint8Array(buffer);\n  return new DataView(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\n}\n","// WASM=never - disable WASM functions\n// WASM=force - force to use WASM functions\nconst WASM: string = process.env.MSGPACK_WASM || process.env.WASM || \"\";\nexport const NO_WASM = WASM === \"never\";\nexport const FORCE_WASM = WASM === \"force\";\n\ntype pointer = number;\n\n// WM stands for WasmModule, but not the WebAssembly.Module instance but the WebAssembly.Instance.prototype.exports\nconst wm: any = (() => {\n  if (NO_WASM) {\n    return null;\n  }\n\n  try {\n    return require(\"../dist/wasm/msgpack.wasm.js\");\n  } catch (e) {\n    if (FORCE_WASM) {\n      throw e;\n    }\n    return null;\n  }\n})();\n\nexport const WASM_AVAILABLE = !!wm;\n\n// A hint of when to use WASM ver.\nexport const WASM_STR_THRESHOLD = FORCE_WASM ? 0 : 1024;\n\nfunction setMemoryU8(destPtr: pointer, src: Uint8Array, size: number) {\n  const destView = new Uint8Array(wm.memory.buffer, destPtr, size);\n  destView.set(src);\n}\n\nfunction setMemoryStr(destPtr: pointer, destByteLength: number, str: string, strLength: number) {\n  const inputView = new DataView(wm.memory.buffer, destPtr, destByteLength);\n  for (let i = 0; i < strLength; i++) {\n    inputView.setUint16(i * 2, str.charCodeAt(i));\n  }\n}\n\n/**\n * It encodes string to MessagePack str family (headByte/size + utf8 bytes).\n * @returns The whole byte length including headByte/size.\n */\nexport function utf8EncodeWasm(str: string, output: Uint8Array, outputOffset: number): number {\n  const strLength = str.length;\n  const inputByteLength = strLength * 2;\n  const inputU16BePtr: pointer = wm.malloc(inputByteLength);\n  setMemoryStr(inputU16BePtr, inputByteLength, str, strLength);\n\n  const maxOutputHeaderSize = 1 + 4; // headByte + u32\n  const outputPtr: pointer = wm.malloc(maxOutputHeaderSize + strLength * 4);\n  try {\n    const outputLength = wm.utf8EncodeUint16Array(outputPtr, inputU16BePtr, strLength);\n    output.set(new Uint8Array(wm.memory.buffer, outputPtr, outputLength), outputOffset);\n    return outputLength;\n  } finally {\n    wm.free(inputU16BePtr);\n    wm.free(outputPtr);\n  }\n}\n\nconst CHUNK_SIZE = 0x10_000;\n\nfunction safeStringFromCharCodeU16(units: Uint16Array) {\n  if (units.length <= CHUNK_SIZE) {\n    // `String.fromCharCode.apply()` is faster than `String.fromCharCode(...units)`\n    // in case `units` is a typed array\n    return String.fromCharCode.apply(String, units as any);\n  }\n\n  let result = \"\";\n  for (let i = 0; i < units.length; i++) {\n    const chunk = units.subarray(i * CHUNK_SIZE, (i + 1) * CHUNK_SIZE);\n    result += String.fromCharCode.apply(String, chunk as any);\n  }\n  return result;\n}\n\n// A wrapper function for utf8DecodeToUint16Array()\nexport function utf8DecodeWasm(bytes: Uint8Array, inputOffset: number, byteLength: number): string {\n  const inputPtr: pointer = wm.malloc(byteLength);\n  // in worst case, the UTF-16 array uses the same as byteLength * 2\n  const outputPtr: pointer = wm.malloc(byteLength * 2);\n  try {\n    setMemoryU8(inputPtr, bytes.subarray(inputOffset, inputOffset + byteLength), byteLength);\n\n    const outputArraySize = wm.utf8DecodeToUint16Array(outputPtr, inputPtr, byteLength);\n    const units = new Uint16Array(wm.memory.buffer, outputPtr, outputArraySize);\n    return safeStringFromCharCodeU16(units);\n  } finally {\n    wm.free(inputPtr);\n    wm.free(outputPtr);\n  }\n}\n","import { utf8EncodeJs, utf8Count, TEXT_ENCODING_AVAILABLE, TEXT_ENCODER_THRESHOLD, utf8EncodeTE } from \"./utils/utf8\";\nimport { ExtensionCodec } from \"./ExtensionCodec\";\nimport { setInt64, setUint64 } from \"./utils/int\";\nimport { ensureUint8Array } from \"./utils/typedArrays\";\nimport { ExtData } from \"./ExtData\";\nimport { WASM_AVAILABLE, utf8EncodeWasm, WASM_STR_THRESHOLD } from \"./wasmFunctions\";\n\nexport const DEFAULT_MAX_DEPTH = 100;\nexport const DEFAULT_INITIAL_BUFFER_SIZE = 2048;\n\nexport class Encoder {\n  private pos = 0;\n  private view = new DataView(new ArrayBuffer(this.initialBufferSize));\n  private bytes = new Uint8Array(this.view.buffer);\n\n  constructor(\n    readonly extensionCodec = ExtensionCodec.defaultCodec,\n    readonly maxDepth = DEFAULT_MAX_DEPTH,\n    readonly initialBufferSize = DEFAULT_INITIAL_BUFFER_SIZE,\n    readonly sortKeys = false,\n    readonly forceFloat32 = false,\n  ) {}\n\n  encode(object: unknown, depth: number): void {\n    if (depth > this.maxDepth) {\n      throw new Error(`Too deep objects in depth ${depth}`);\n    }\n\n    if (object == null) {\n      this.encodeNil();\n    } else if (typeof object === \"boolean\") {\n      this.encodeBoolean(object);\n    } else if (typeof object === \"number\") {\n      this.encodeNumber(object);\n    } else if (typeof object === \"string\") {\n      this.encodeString(object);\n    } else {\n      this.encodeObject(object, depth);\n    }\n  }\n\n  getUint8Array(): Uint8Array {\n    return this.bytes.subarray(0, this.pos);\n  }\n\n  ensureBufferSizeToWrite(sizeToWrite: number) {\n    const requiredSize = this.pos + sizeToWrite;\n\n    if (this.view.byteLength < requiredSize) {\n      this.resizeBuffer(requiredSize * 2);\n    }\n  }\n\n  resizeBuffer(newSize: number) {\n    const newBuffer = new ArrayBuffer(newSize);\n    const newBytes = new Uint8Array(newBuffer);\n    const newView = new DataView(newBuffer);\n\n    newBytes.set(this.bytes);\n\n    this.view = newView;\n    this.bytes = newBytes;\n  }\n\n  encodeNil() {\n    this.writeU8(0xc0);\n  }\n\n  encodeBoolean(object: boolean) {\n    if (object === false) {\n      this.writeU8(0xc2);\n    } else {\n      this.writeU8(0xc3);\n    }\n  }\n  encodeNumber(object: number) {\n    if (Number.isSafeInteger(object)) {\n      if (object >= 0) {\n        if (object < 0x80) {\n          // positive fixint\n          this.writeU8(object);\n        } else if (object < 0x100) {\n          // uint 8\n          this.writeU8(0xcc);\n          this.writeU8(object);\n        } else if (object < 0x10000) {\n          // uint 16\n          this.writeU8(0xcd);\n          this.writeU16(object);\n        } else if (object < 0x100000000) {\n          // uint 32\n          this.writeU8(0xce);\n          this.writeU32(object);\n        } else {\n          // uint 64\n          this.writeU8(0xcf);\n          this.writeU64(object);\n        }\n      } else {\n        if (object >= -0x20) {\n          // nagative fixint\n          this.writeU8(0xe0 | (object + 0x20));\n        } else if (object >= -0x80) {\n          // int 8\n          this.writeU8(0xd0);\n          this.writeI8(object);\n        } else if (object >= -0x8000) {\n          // int 16\n          this.writeU8(0xd1);\n          this.writeI16(object);\n        } else if (object >= -0x80000000) {\n          // int 32\n          this.writeU8(0xd2);\n          this.writeI32(object);\n        } else {\n          // int 64\n          this.writeU8(0xd3);\n          this.writeI64(object);\n        }\n      }\n    } else {\n      // non-integer numbers\n      if (this.forceFloat32) {\n        // float 32\n        this.writeU8(0xca);\n        this.writeF32(object);\n      } else {\n        // float 64\n        this.writeU8(0xcb);\n        this.writeF64(object);\n      }\n    }\n  }\n\n  writeStringHeader(byteLength: number) {\n    if (byteLength < 32) {\n      // fixstr\n      this.writeU8(0xa0 + byteLength);\n    } else if (byteLength < 0x100) {\n      // str 8\n      this.writeU8(0xd9);\n      this.writeU8(byteLength);\n    } else if (byteLength < 0x10000) {\n      // str 16\n      this.writeU8(0xda);\n      this.writeU16(byteLength);\n    } else if (byteLength < 0x100000000) {\n      // str 32\n      this.writeU8(0xdb);\n      this.writeU32(byteLength);\n    } else {\n      throw new Error(`Too long string: ${byteLength} bytes in UTF-8`);\n    }\n  }\n\n  encodeString(object: string) {\n    const maxHeaderSize = 1 + 4;\n    const strLength = object.length;\n\n    if (TEXT_ENCODING_AVAILABLE && strLength > TEXT_ENCODER_THRESHOLD) {\n      const byteLength = utf8Count(object);\n      this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\n      this.writeStringHeader(byteLength);\n      utf8EncodeTE(object, this.bytes, this.pos);\n      this.pos += byteLength;\n    } else if (WASM_AVAILABLE && strLength > WASM_STR_THRESHOLD) {\n      // ensure max possible size\n      const maxSize = maxHeaderSize + strLength * 4;\n      this.ensureBufferSizeToWrite(maxSize);\n\n      // utf8EncodeWasm() handles headByte+size as well as string itself\n      const ouputLength = utf8EncodeWasm(object, this.bytes, this.pos);\n      this.pos += ouputLength;\n      return;\n    } else {\n      const byteLength = utf8Count(object);\n      this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\n      this.writeStringHeader(byteLength);\n      utf8EncodeJs(object, this.bytes, this.pos);\n      this.pos += byteLength;\n    }\n  }\n\n  encodeObject(object: unknown, depth: number) {\n    // try to encode objects with custom codec first of non-primitives\n    const ext = this.extensionCodec.tryToEncode(object);\n    if (ext != null) {\n      this.encodeExtension(ext);\n    } else if (Array.isArray(object)) {\n      this.encodeArray(object, depth);\n    } else if (ArrayBuffer.isView(object)) {\n      this.encodeBinary(object);\n    } else if (typeof object === \"object\") {\n      this.encodeMap(object as Record<string, unknown>, depth);\n    } else {\n      // symbol, function and other special object come here unless extensionCodec handles them.\n      throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(object)}`);\n    }\n  }\n\n  encodeBinary(object: ArrayBufferView) {\n    const size = object.byteLength;\n    if (size < 0x100) {\n      // bin 8\n      this.writeU8(0xc4);\n      this.writeU8(size);\n    } else if (size < 0x10000) {\n      // bin 16\n      this.writeU8(0xc5);\n      this.writeU16(size);\n    } else if (size < 0x100000000) {\n      // bin 32\n      this.writeU8(0xc6);\n      this.writeU32(size);\n    } else {\n      throw new Error(`Too large binary: ${size}`);\n    }\n    const bytes = ensureUint8Array(object);\n    this.writeU8a(bytes);\n  }\n\n  encodeArray(object: Array<unknown>, depth: number) {\n    const size = object.length;\n    if (size < 16) {\n      // fixarray\n      this.writeU8(0x90 + size);\n    } else if (size < 0x10000) {\n      // array 16\n      this.writeU8(0xdc);\n      this.writeU16(size);\n    } else if (size < 0x100000000) {\n      // array 32\n      this.writeU8(0xdd);\n      this.writeU32(size);\n    } else {\n      throw new Error(`Too large array: ${size}`);\n    }\n    for (const item of object) {\n      this.encode(item, depth + 1);\n    }\n  }\n\n  encodeMap(object: Record<string, unknown>, depth: number) {\n    const keys = Object.keys(object);\n    if (this.sortKeys) {\n      keys.sort();\n    }\n    const size = keys.length;\n    if (size < 16) {\n      // fixmap\n      this.writeU8(0x80 + size);\n    } else if (size < 0x10000) {\n      // map 16\n      this.writeU8(0xde);\n      this.writeU16(size);\n    } else if (size < 0x100000000) {\n      // map 32\n      this.writeU8(0xdf);\n      this.writeU32(size);\n    } else {\n      throw new Error(`Too large map object: ${size}`);\n    }\n\n    for (let i = 0; i < size; i++) {\n      const key = keys[i];\n      this.encodeString(key);\n      this.encode(object[key], depth + 1);\n    }\n  }\n\n  encodeExtension(ext: ExtData) {\n    const size = ext.data.length;\n    if (size === 1) {\n      // fixext 1\n      this.writeU8(0xd4);\n    } else if (size === 2) {\n      // fixext 2\n      this.writeU8(0xd5);\n    } else if (size === 4) {\n      // fixext 4\n      this.writeU8(0xd6);\n    } else if (size === 8) {\n      // fixext 8\n      this.writeU8(0xd7);\n    } else if (size === 16) {\n      // fixext 16\n      this.writeU8(0xd8);\n    } else if (size < 0x100) {\n      // ext 8\n      this.writeU8(0xc7);\n      this.writeU8(size);\n    } else if (size < 0x10000) {\n      // ext 16\n      this.writeU8(0xc8);\n      this.writeU16(size);\n    } else if (size < 0x100000000) {\n      // ext 32\n      this.writeU8(0xc9);\n      this.writeU32(size);\n    } else {\n      throw new Error(`Too large extension object: ${size}`);\n    }\n    this.writeI8(ext.type);\n    this.writeU8a(ext.data);\n  }\n\n  writeU8(value: number) {\n    this.ensureBufferSizeToWrite(1);\n\n    this.view.setUint8(this.pos, value);\n    this.pos++;\n  }\n\n  writeU8a(values: ArrayLike<number>) {\n    const size = values.length;\n    this.ensureBufferSizeToWrite(size);\n\n    this.bytes.set(values, this.pos);\n    this.pos += size;\n  }\n\n  writeI8(value: number) {\n    this.ensureBufferSizeToWrite(1);\n\n    this.view.setInt8(this.pos, value);\n    this.pos++;\n  }\n\n  writeU16(value: number) {\n    this.ensureBufferSizeToWrite(2);\n\n    this.view.setUint16(this.pos, value);\n    this.pos += 2;\n  }\n\n  writeI16(value: number) {\n    this.ensureBufferSizeToWrite(2);\n\n    this.view.setInt16(this.pos, value);\n    this.pos += 2;\n  }\n\n  writeU32(value: number) {\n    this.ensureBufferSizeToWrite(4);\n\n    this.view.setUint32(this.pos, value);\n    this.pos += 4;\n  }\n\n  writeI32(value: number) {\n    this.ensureBufferSizeToWrite(4);\n\n    this.view.setInt32(this.pos, value);\n    this.pos += 4;\n  }\n\n  writeF32(value: number) {\n    this.ensureBufferSizeToWrite(4);\n    this.view.setFloat32(this.pos, value);\n    this.pos += 4;\n  }\n\n  writeF64(value: number) {\n    this.ensureBufferSizeToWrite(8);\n    this.view.setFloat64(this.pos, value);\n    this.pos += 8;\n  }\n\n  writeU64(value: number) {\n    this.ensureBufferSizeToWrite(8);\n\n    setUint64(this.view, this.pos, value);\n    this.pos += 8;\n  }\n\n  writeI64(value: number) {\n    this.ensureBufferSizeToWrite(8);\n\n    setInt64(this.view, this.pos, value);\n    this.pos += 8;\n  }\n}\n","import { ExtensionCodecType } from \"./ExtensionCodec\";\nimport { Encoder } from \"./Encoder\";\n\nexport type EncodeOptions = Partial<\n  Readonly<{\n    extensionCodec: ExtensionCodecType;\n    maxDepth: number;\n    initialBufferSize: number;\n    sortKeys: boolean;\n\n    /**\n     * If `true`, non-integer numbers are encoded in float32, not in float64 (the default).\n     *\n     * Only use it if precisions don't matter.\n     */\n    forceFloat32: boolean;\n  }>\n>;\n\nconst defaultEncodeOptions = {};\n\n/**\n * It encodes `value` in the MessagePack format and\n * returns a byte buffer.\n *\n * The returned buffer is a slice of a larger `ArrayBuffer`, so you have to use its `#byteOffset` and `#byteLength` in order to convert it to another typed arrays including NodeJS `Buffer`.\n */\nexport function encode(value: unknown, options: EncodeOptions = defaultEncodeOptions): Uint8Array {\n  const encoder = new Encoder(\n    options.extensionCodec,\n    options.maxDepth,\n    options.initialBufferSize,\n    options.sortKeys,\n    options.forceFloat32,\n  );\n  encoder.encode(value, 1);\n  return encoder.getUint8Array();\n}\n","export function prettyByte(byte: number): string {\n  return `${byte < 0 ? \"-\" : \"\"}0x${Math.abs(byte)\n    .toString(16)\n    .padStart(2, \"0\")}`;\n}\n","import { utf8DecodeJs } from \"./utils/utf8\";\n\ninterface KeyCacheRecord {\n  readonly bytes: Uint8Array;\n  readonly value: string;\n}\n\nconst DEFAULT_MAX_KEY_LENGTH = 16;\nconst DEFAULT_MAX_LENGTH_PER_KEY = 16;\n\nexport class CachedKeyDecoder {\n  private readonly caches: Array<Array<KeyCacheRecord>>;\n\n  constructor(readonly maxKeyLength = DEFAULT_MAX_KEY_LENGTH, readonly maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY) {\n    // avoid `new Array(N)` to create a non-sparse array for performance.\n    this.caches = [];\n    for (let i = 0; i < this.maxKeyLength; i++) {\n      this.caches.push([]);\n    }\n  }\n\n  public canBeCached(byteLength: number) {\n    return byteLength > 0 && byteLength <= this.maxKeyLength;\n  }\n\n  private get(bytes: Uint8Array, inputOffset: number, byteLength: number): string | null {\n    const records = this.caches[byteLength - 1];\n    const recordsLength = records.length;\n\n    FIND_CHUNK: for (let i = 0; i < recordsLength; i++) {\n      const record = records[i];\n      const recordBytes = record.bytes;\n\n      for (let j = 0; j < byteLength; j++) {\n        if (recordBytes[j] !== bytes[inputOffset + j]) {\n          continue FIND_CHUNK;\n        }\n      }\n      return record.value;\n    }\n    return null;\n  }\n\n  private store(bytes: Uint8Array, value: string) {\n    const records = this.caches[bytes.length - 1];\n    const record: KeyCacheRecord = { bytes, value };\n\n    if (records.length >= this.maxLengthPerKey) {\n      // `records` are full!\n      // Set `record` to a randomized position.\n      records[(Math.random() * records.length) | 0] = record;\n    } else {\n      records.push(record);\n    }\n  }\n\n  public decode(bytes: Uint8Array, inputOffset: number, byteLength: number): string {\n    const cachedValue = this.get(bytes, inputOffset, byteLength);\n    if (cachedValue) {\n      return cachedValue;\n    }\n\n    const value = utf8DecodeJs(bytes, inputOffset, byteLength);\n    // Ensure to copy a slice of bytes because the byte may be NodeJS Buffer and Buffer#slice() returns a reference to its internal ArrayBuffer.\n    const slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);\n    this.store(slicedCopyOfBytes, value);\n    return value;\n  }\n}\n","import { prettyByte } from \"./utils/prettyByte\";\nimport { ExtensionCodec } from \"./ExtensionCodec\";\nimport { getInt64, getUint64 } from \"./utils/int\";\nimport { utf8DecodeJs, TEXT_ENCODING_AVAILABLE, TEXT_DECODER_THRESHOLD, utf8DecodeTD } from \"./utils/utf8\";\nimport { createDataView, ensureUint8Array } from \"./utils/typedArrays\";\nimport { WASM_AVAILABLE, WASM_STR_THRESHOLD, utf8DecodeWasm } from \"./wasmFunctions\";\nimport { CachedKeyDecoder } from \"./CachedKeyDecoder\";\n\nconst enum State {\n  ARRAY,\n  MAP_KEY,\n  MAP_VALUE,\n}\n\ntype MapKeyType = string | number;\n\nconst isValidMapKeyType = (key: unknown): key is MapKeyType => {\n  const keyType = typeof key;\n\n  return keyType === \"string\" || keyType === \"number\";\n};\n\ntype StackMapState = {\n  type: State.MAP_KEY | State.MAP_VALUE;\n  size: number;\n  key: MapKeyType | null;\n  readCount: number;\n  map: Record<string, unknown>;\n};\n\ntype StackArrayState = {\n  type: State.ARRAY;\n  size: number;\n  array: Array<unknown>;\n  position: number;\n};\n\ntype StackState = StackArrayState | StackMapState;\n\nconst HEAD_BYTE_REQUIRED = -1;\n\nconst EMPTY_VIEW = new DataView(new ArrayBuffer(0));\nconst EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer);\n\n// IE11: Hack to support IE11.\n// IE11: Drop this hack and just use RangeError when IE11 is obsolete.\nexport const DataViewIndexOutOfBoundsError: typeof Error = (() => {\n  try {\n    // IE11: The spec says it should throw RangeError,\n    // IE11: but in IE11 it throws TypeError.\n    EMPTY_VIEW.getInt8(0);\n  } catch (e) {\n    return e.constructor;\n  }\n  throw new Error(\"never reached\");\n})();\n\nconst MORE_DATA = new DataViewIndexOutOfBoundsError(\"Insufficient data\");\n\nconst DEFAULT_MAX_LENGTH = 0xffff_ffff; // uint32_max\n\nconst sharedCachedKeyDecoder = new CachedKeyDecoder();\n\nexport class Decoder {\n  totalPos = 0;\n  pos = 0;\n\n  view = EMPTY_VIEW;\n  bytes = EMPTY_BYTES;\n  headByte = HEAD_BYTE_REQUIRED;\n  readonly stack: Array<StackState> = [];\n\n  constructor(\n    readonly extensionCodec = ExtensionCodec.defaultCodec,\n    readonly maxStrLength = DEFAULT_MAX_LENGTH,\n    readonly maxBinLength = DEFAULT_MAX_LENGTH,\n    readonly maxArrayLength = DEFAULT_MAX_LENGTH,\n    readonly maxMapLength = DEFAULT_MAX_LENGTH,\n    readonly maxExtLength = DEFAULT_MAX_LENGTH,\n    readonly cachedKeyDecoder: CachedKeyDecoder | null = sharedCachedKeyDecoder,\n  ) {}\n\n  setBuffer(buffer: ArrayLike<number> | ArrayBuffer): void {\n    this.bytes = ensureUint8Array(buffer);\n    this.view = createDataView(this.bytes);\n    this.pos = 0;\n  }\n\n  appendBuffer(buffer: ArrayLike<number>) {\n    if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining()) {\n      this.setBuffer(buffer);\n    } else {\n      // retried because data is insufficient\n      const remainingData = this.bytes.subarray(this.pos);\n      const newData = ensureUint8Array(buffer);\n      const concated = new Uint8Array(remainingData.length + newData.length);\n      concated.set(remainingData);\n      concated.set(newData, remainingData.length);\n      this.setBuffer(concated);\n    }\n  }\n\n  hasRemaining(size = 1) {\n    return this.view.byteLength - this.pos >= size;\n  }\n\n  createNoExtraBytesError(posToShow: number): Error {\n    const { view, pos } = this;\n    return new RangeError(`Extra ${view.byteLength - pos} byte(s) found at buffer[${posToShow}]`);\n  }\n\n  decodeSingleSync(): unknown {\n    const object = this.decodeSync();\n    if (this.hasRemaining()) {\n      throw this.createNoExtraBytesError(this.pos);\n    }\n    return object;\n  }\n\n  async decodeSingleAsync(stream: AsyncIterable<ArrayLike<number>>): Promise<unknown> {\n    let decoded = false;\n    let object: unknown;\n    for await (const buffer of stream) {\n      if (decoded) {\n        throw this.createNoExtraBytesError(this.totalPos);\n      }\n\n      this.appendBuffer(buffer);\n\n      try {\n        object = this.decodeSync();\n        decoded = true;\n      } catch (e) {\n        if (!(e instanceof DataViewIndexOutOfBoundsError)) {\n          throw e; // rethrow\n        }\n        // fallthrough\n      }\n      this.totalPos += this.pos;\n    }\n\n    if (decoded) {\n      if (this.hasRemaining()) {\n        throw this.createNoExtraBytesError(this.totalPos);\n      }\n      return object;\n    }\n\n    const { headByte, pos, totalPos } = this;\n    throw new RangeError(\n      `Insufficient data in parcing ${prettyByte(headByte)} at ${totalPos} (${pos} in the current buffer)`,\n    );\n  }\n\n  decodeArrayStream(stream: AsyncIterable<ArrayLike<number>>) {\n    return this.decodeMultiAsync(stream, true);\n  }\n\n  decodeStream(stream: AsyncIterable<ArrayLike<number>>) {\n    return this.decodeMultiAsync(stream, false);\n  }\n\n  private async *decodeMultiAsync(stream: AsyncIterable<ArrayLike<number>>, isArray: boolean) {\n    let isArrayHeaderRequired = isArray;\n    let arrayItemsLeft = -1;\n\n    for await (const buffer of stream) {\n      if (isArray && arrayItemsLeft === 0) {\n        throw this.createNoExtraBytesError(this.totalPos);\n      }\n\n      this.appendBuffer(buffer);\n\n      if (isArrayHeaderRequired) {\n        arrayItemsLeft = this.readArraySize();\n        isArrayHeaderRequired = false;\n        this.complete();\n      }\n\n      try {\n        while (true) {\n          yield this.decodeSync();\n          if (--arrayItemsLeft === 0) {\n            break;\n          }\n        }\n      } catch (e) {\n        if (!(e instanceof DataViewIndexOutOfBoundsError)) {\n          throw e; // rethrow\n        }\n        // fallthrough\n      }\n      this.totalPos += this.pos;\n    }\n  }\n\n  decodeSync(): unknown {\n    DECODE: while (true) {\n      const headByte = this.readHeadByte();\n      let object: unknown;\n\n      if (headByte >= 0xe0) {\n        // negative fixint (111x xxxx) 0xe0 - 0xff\n        object = headByte - 0x100;\n      } else if (headByte < 0xc0) {\n        if (headByte < 0x80) {\n          // positive fixint (0xxx xxxx) 0x00 - 0x7f\n          object = headByte;\n        } else if (headByte < 0x90) {\n          // fixmap (1000 xxxx) 0x80 - 0x8f\n          const size = headByte - 0x80;\n          if (size !== 0) {\n            this.pushMapState(size);\n            this.complete();\n            continue DECODE;\n          } else {\n            object = {};\n          }\n        } else if (headByte < 0xa0) {\n          // fixarray (1001 xxxx) 0x90 - 0x9f\n          const size = headByte - 0x90;\n          if (size !== 0) {\n            this.pushArrayState(size);\n            this.complete();\n            continue DECODE;\n          } else {\n            object = [];\n          }\n        } else {\n          // fixstr (101x xxxx) 0xa0 - 0xbf\n          const byteLength = headByte - 0xa0;\n          object = this.decodeUtf8String(byteLength, 0);\n        }\n      } else if (headByte === 0xc0) {\n        // nil\n        object = null;\n      } else if (headByte === 0xc2) {\n        // false\n        object = false;\n      } else if (headByte === 0xc3) {\n        // true\n        object = true;\n      } else if (headByte === 0xca) {\n        // float 32\n        object = this.readF32();\n      } else if (headByte === 0xcb) {\n        // float 64\n        object = this.readF64();\n      } else if (headByte === 0xcc) {\n        // uint 8\n        object = this.readU8();\n      } else if (headByte === 0xcd) {\n        // uint 16\n        object = this.readU16();\n      } else if (headByte === 0xce) {\n        // uint 32\n        object = this.readU32();\n      } else if (headByte === 0xcf) {\n        // uint 64\n        object = this.readU64();\n      } else if (headByte === 0xd0) {\n        // int 8\n        object = this.readI8();\n      } else if (headByte === 0xd1) {\n        // int 16\n        object = this.readI16();\n      } else if (headByte === 0xd2) {\n        // int 32\n        object = this.readI32();\n      } else if (headByte === 0xd3) {\n        // int 64\n        object = this.readI64();\n      } else if (headByte === 0xd9) {\n        // str 8\n        const byteLength = this.lookU8();\n        object = this.decodeUtf8String(byteLength, 1);\n      } else if (headByte === 0xda) {\n        // str 16\n        const byteLength = this.lookU16();\n        object = this.decodeUtf8String(byteLength, 2);\n      } else if (headByte === 0xdb) {\n        // str 32\n        const byteLength = this.lookU32();\n        object = this.decodeUtf8String(byteLength, 4);\n      } else if (headByte === 0xdc) {\n        // array 16\n        const size = this.readU16();\n        if (size !== 0) {\n          this.pushArrayState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = [];\n        }\n      } else if (headByte === 0xdd) {\n        // array 32\n        const size = this.readU32();\n        if (size !== 0) {\n          this.pushArrayState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = [];\n        }\n      } else if (headByte === 0xde) {\n        // map 16\n        const size = this.readU16();\n        if (size !== 0) {\n          this.pushMapState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = {};\n        }\n      } else if (headByte === 0xdf) {\n        // map 32\n        const size = this.readU32();\n        if (size !== 0) {\n          this.pushMapState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = {};\n        }\n      } else if (headByte === 0xc4) {\n        // bin 8\n        const size = this.lookU8();\n        object = this.decodeBinary(size, 1);\n      } else if (headByte === 0xc5) {\n        // bin 16\n        const size = this.lookU16();\n        object = this.decodeBinary(size, 2);\n      } else if (headByte === 0xc6) {\n        // bin 32\n        const size = this.lookU32();\n        object = this.decodeBinary(size, 4);\n      } else if (headByte === 0xd4) {\n        // fixext 1\n        object = this.decodeExtension(1, 0);\n      } else if (headByte === 0xd5) {\n        // fixext 2\n        object = this.decodeExtension(2, 0);\n      } else if (headByte === 0xd6) {\n        // fixext 4\n        object = this.decodeExtension(4, 0);\n      } else if (headByte === 0xd7) {\n        // fixext 8\n        object = this.decodeExtension(8, 0);\n      } else if (headByte === 0xd8) {\n        // fixext 16\n        object = this.decodeExtension(16, 0);\n      } else if (headByte === 0xc7) {\n        // ext 8\n        const size = this.lookU8();\n        object = this.decodeExtension(size, 1);\n      } else if (headByte === 0xc8) {\n        // ext 16\n        const size = this.lookU16();\n        object = this.decodeExtension(size, 2);\n      } else if (headByte === 0xc9) {\n        // ext 32\n        const size = this.lookU32();\n        object = this.decodeExtension(size, 4);\n      } else {\n        throw new Error(`Unrecognized type byte: ${prettyByte(headByte)}`);\n      }\n\n      this.complete();\n\n      const stack = this.stack;\n      while (stack.length > 0) {\n        // arrays and maps\n        const state = stack[stack.length - 1];\n        if (state.type === State.ARRAY) {\n          state.array[state.position] = object;\n          state.position++;\n          if (state.position === state.size) {\n            stack.pop();\n            object = state.array;\n          } else {\n            continue DECODE;\n          }\n        } else if (state.type === State.MAP_KEY) {\n          if (!isValidMapKeyType(object)) {\n            throw new Error(\"The type of key must be string or number but \" + typeof object);\n          }\n\n          state.key = object;\n          state.type = State.MAP_VALUE;\n          continue DECODE;\n        } else if (state.type === State.MAP_VALUE) {\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          state.map[state.key!] = object;\n          state.readCount++;\n\n          if (state.readCount === state.size) {\n            stack.pop();\n            object = state.map;\n          } else {\n            state.key = null;\n            state.type = State.MAP_KEY;\n            continue DECODE;\n          }\n        }\n      }\n\n      return object;\n    }\n  }\n\n  readHeadByte(): number {\n    if (this.headByte === HEAD_BYTE_REQUIRED) {\n      this.headByte = this.readU8();\n      // console.log(\"headByte\", prettyByte(this.headByte));\n    }\n\n    return this.headByte;\n  }\n\n  complete(): void {\n    this.headByte = HEAD_BYTE_REQUIRED;\n  }\n\n  readArraySize(): number {\n    const headByte = this.readHeadByte();\n\n    switch (headByte) {\n      case 0xdc:\n        return this.readU16();\n      case 0xdd:\n        return this.readU32();\n      default: {\n        if (headByte < 0xa0) {\n          return headByte - 0x90;\n        } else {\n          throw new Error(`Unrecognized array type byte: ${prettyByte(headByte)}`);\n        }\n      }\n    }\n  }\n\n  pushMapState(size: number) {\n    if (size > this.maxMapLength) {\n      throw new Error(`Max length exceeded: map length (${size}) > maxMapLengthLength (${this.maxMapLength})`);\n    }\n\n    this.stack.push({\n      type: State.MAP_KEY,\n      size,\n      key: null,\n      readCount: 0,\n      map: {},\n    });\n  }\n\n  pushArrayState(size: number) {\n    if (size > this.maxArrayLength) {\n      throw new Error(`Max length exceeded: array length (${size}) > maxArrayLength (${this.maxArrayLength})`);\n    }\n\n    this.stack.push({\n      type: State.ARRAY,\n      size,\n      array: new Array<unknown>(size),\n      position: 0,\n    });\n  }\n\n  decodeUtf8String(byteLength: number, headerOffset: number): string {\n    if (byteLength > this.maxStrLength) {\n      throw new Error(`Max length exceeded: UTF-8 byte length (${byteLength}) > maxStrLength (${this.maxStrLength})`);\n    }\n\n    if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {\n      throw MORE_DATA;\n    }\n\n    const offset = this.pos + headerOffset;\n    let object: string;\n    if (this.cachedKeyDecoder && this.stateIsMapKey() && this.cachedKeyDecoder.canBeCached(byteLength)) {\n      object = this.cachedKeyDecoder.decode(this.bytes, offset, byteLength);\n    } else if (TEXT_ENCODING_AVAILABLE && byteLength > TEXT_DECODER_THRESHOLD) {\n      object = utf8DecodeTD(this.bytes, offset, byteLength);\n    } else if (WASM_AVAILABLE && byteLength > WASM_STR_THRESHOLD) {\n      object = utf8DecodeWasm(this.bytes, offset, byteLength);\n    } else {\n      object = utf8DecodeJs(this.bytes, offset, byteLength);\n    }\n    this.pos += headerOffset + byteLength;\n    return object;\n  }\n\n  stateIsMapKey(): boolean {\n    if (this.stack.length > 0) {\n      const state = this.stack[this.stack.length - 1];\n      return state.type === State.MAP_KEY;\n    }\n    return false;\n  }\n\n  decodeBinary(byteLength: number, headOffset: number): Uint8Array {\n    if (byteLength > this.maxBinLength) {\n      throw new Error(`Max length exceeded: bin length (${byteLength}) > maxBinLength (${this.maxBinLength})`);\n    }\n\n    if (!this.hasRemaining(byteLength + headOffset)) {\n      throw MORE_DATA;\n    }\n\n    const offset = this.pos + headOffset;\n    const object = this.bytes.subarray(offset, offset + byteLength);\n    this.pos += headOffset + byteLength;\n    return object;\n  }\n\n  decodeExtension(size: number, headOffset: number): unknown {\n    if (size > this.maxExtLength) {\n      throw new Error(`Max length exceeded: ext length (${size}) > maxExtLength (${this.maxExtLength})`);\n    }\n\n    const extType = this.view.getInt8(this.pos + headOffset);\n    const data = this.decodeBinary(size, headOffset + 1 /* extType */);\n    return this.extensionCodec.decode(data, extType);\n  }\n\n  lookU8() {\n    return this.view.getUint8(this.pos);\n  }\n\n  lookU16() {\n    return this.view.getUint16(this.pos);\n  }\n\n  lookU32() {\n    return this.view.getUint32(this.pos);\n  }\n\n  readU8(): number {\n    const value = this.view.getUint8(this.pos);\n    this.pos++;\n    return value;\n  }\n\n  readI8(): number {\n    const value = this.view.getInt8(this.pos);\n    this.pos++;\n    return value;\n  }\n\n  readU16(): number {\n    const value = this.view.getUint16(this.pos);\n    this.pos += 2;\n    return value;\n  }\n\n  readI16(): number {\n    const value = this.view.getInt16(this.pos);\n    this.pos += 2;\n    return value;\n  }\n\n  readU32(): number {\n    const value = this.view.getUint32(this.pos);\n    this.pos += 4;\n    return value;\n  }\n\n  readI32(): number {\n    const value = this.view.getInt32(this.pos);\n    this.pos += 4;\n    return value;\n  }\n\n  readU64(): number {\n    const value = getUint64(this.view, this.pos);\n    this.pos += 8;\n    return value;\n  }\n\n  readI64(): number {\n    const value = getInt64(this.view, this.pos);\n    this.pos += 8;\n    return value;\n  }\n\n  readF32() {\n    const value = this.view.getFloat32(this.pos);\n    this.pos += 4;\n    return value;\n  }\n\n  readF64() {\n    const value = this.view.getFloat64(this.pos);\n    this.pos += 8;\n    return value;\n  }\n}\n","import { ExtensionCodecType } from \"./ExtensionCodec\";\nimport { Decoder } from \"./Decoder\";\n\nexport type DecodeOptions = Partial<\n  Readonly<{\n    extensionCodec: ExtensionCodecType;\n\n    /**\n     * Maximum string length.\n     * Default to 4_294_967_295 (UINT32_MAX).\n     */\n    maxStrLength: number;\n    /**\n     * Maximum binary length.\n     * Default to 4_294_967_295 (UINT32_MAX).\n     */\n    maxBinLength: number;\n    /**\n     * Maximum array length.\n     * Default to 4_294_967_295 (UINT32_MAX).\n     */\n    maxArrayLength: number;\n    /**\n     * Maximum map length.\n     * Default to 4_294_967_295 (UINT32_MAX).\n     */\n    maxMapLength: number;\n    /**\n     * Maximum extension length.\n     * Default to 4_294_967_295 (UINT32_MAX).\n     */\n    maxExtLength: number;\n  }>\n>;\n\nexport const defaultDecodeOptions: DecodeOptions = {};\n\n/**\n * It decodes a MessagePack-encoded buffer.\n *\n * This is a synchronous decoding function. See other variants for asynchronous decoding: `decodeAsync()`, `decodeStream()`, `decodeArrayStream()`.\n */\nexport function decode(\n  buffer: ArrayLike<number> | ArrayBuffer,\n  options: DecodeOptions = defaultDecodeOptions,\n): unknown {\n  const decoder = new Decoder(\n    options.extensionCodec,\n    options.maxStrLength,\n    options.maxBinLength,\n    options.maxArrayLength,\n    options.maxMapLength,\n    options.maxExtLength,\n  );\n  decoder.setBuffer(buffer); // decodeSync() requires only one buffer\n  return decoder.decodeSingleSync();\n}\n","// utility for whatwg streams\n\n// The living standard of whatwg streams says\n// ReadableStream is also AsyncIterable, but\n// as of June 2019, no browser implements it.\n// See https://streams.spec.whatwg.org/ for details\nexport type ReadableStreamLike<T> = AsyncIterable<T> | ReadableStream<T>;\n\nexport function isAsyncIterable<T>(object: object): object is AsyncIterable<T> {\n  return (object as any)[Symbol.asyncIterator] != null;\n}\n\nexport async function* asyncIterableFromStream<T>(stream: ReadableStream<T>): AsyncIterable<T> {\n  const reader = stream.getReader();\n\n  try {\n    while (true) {\n      const { done, value } = await reader.read();\n      if (done) {\n        return;\n      }\n      yield value;\n    }\n  } finally {\n    reader.releaseLock();\n  }\n}\n\nexport function ensureAsyncIterabe<T>(streamLike: ReadableStreamLike<T>): AsyncIterable<T> {\n  if (isAsyncIterable(streamLike)) {\n    return streamLike;\n  } else {\n    return asyncIterableFromStream(streamLike);\n  }\n}\n","import { Decoder } from \"./Decoder\";\nimport { defaultDecodeOptions, DecodeOptions } from \"./decode\";\nimport { ensureAsyncIterabe, ReadableStreamLike } from \"./utils/stream\";\n\nexport type DecodeAsyncOptions = DecodeOptions;\nexport const defaultDecodeAsyncOptions = defaultDecodeOptions;\n\nexport async function decodeAsync(\n  streamLike: ReadableStreamLike<ArrayLike<number>>,\n  options: DecodeAsyncOptions = defaultDecodeOptions,\n): Promise<unknown> {\n  const stream = ensureAsyncIterabe(streamLike);\n\n  const decoder = new Decoder(\n    options.extensionCodec,\n    options.maxStrLength,\n    options.maxBinLength,\n    options.maxArrayLength,\n    options.maxMapLength,\n    options.maxExtLength,\n  );\n  return decoder.decodeSingleAsync(stream);\n}\n\nexport function decodeArrayStream(\n  streamLike: ReadableStreamLike<ArrayLike<number>>,\n  options: DecodeAsyncOptions = defaultDecodeOptions,\n) {\n  const stream = ensureAsyncIterabe(streamLike);\n\n  const decoder = new Decoder(\n    options.extensionCodec,\n    options.maxStrLength,\n    options.maxBinLength,\n    options.maxArrayLength,\n    options.maxMapLength,\n    options.maxExtLength,\n  );\n\n  return decoder.decodeArrayStream(stream);\n}\n\nexport function decodeStream(\n  streamLike: ReadableStreamLike<ArrayLike<number>>,\n  options: DecodeAsyncOptions = defaultDecodeOptions,\n) {\n  const stream = ensureAsyncIterabe(streamLike);\n\n  const decoder = new Decoder(\n    options.extensionCodec,\n    options.maxStrLength,\n    options.maxBinLength,\n    options.maxArrayLength,\n    options.maxMapLength,\n    options.maxExtLength,\n  );\n\n  return decoder.decodeStream(stream);\n}\n","// Main Functions:\n\nexport { encode } from \"./encode\";\nexport { decode } from \"./decode\";\nexport { decodeAsync, decodeArrayStream, decodeStream } from \"./decodeAsync\";\n\n/**\n * @experimental `Decoder` is exported for experimental use.\n */\nexport { Decoder } from \"./Decoder\";\n\n/**\n * @experimental `Encoder` is exported for experimental use.\n */\nexport { Encoder } from \"./Encoder\";\n\n// Utilitiies for Extension Types:\n\nexport { ExtensionCodec, ExtensionCodecType, ExtensionDecoderType, ExtensionEncoderType } from \"./ExtensionCodec\";\nexport { ExtData } from \"./ExtData\";\nexport {\n  EXT_TIMESTAMP,\n  encodeDateToTimeSpec,\n  encodeTimeSpecToTimestamp,\n  decodeTimestampToTimeSpec,\n  encodeTimestampExtension,\n  decodeTimestampExtension,\n} from \"./timestamp\";\n\n/**\n * @experimental WebAssembly backend is experimenal.\n */\nexport { WASM_AVAILABLE as __WASM_AVAILABLE } from \"./wasmFunctions\";\n"],"sourceRoot":""}